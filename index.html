<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>tiago morais morgado // digital atoms</title>
    <meta name="description" content="Generative 3D art by Tiago Morais Morgado – Composer, Coder & Conceptual Engineer of Improvised Systems">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title" content="tiago morais morgado">
    <meta property="og:description" content="Blending AI, Free Improvisation & Experimental Audiovisual Languages • three.js">
    <meta property="og:image" content="https://tiagomoraismorgado.github.io/og-image.jpg">
    <meta property="og:url" content="https://tiagomoraismorgado.github.io">
    <meta name="twitter:card" content="summary_large_image">

    <style>
      body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
      canvas { display: block; }

      .text-container {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        pointer-events: none;
      }

      .backdrop {
        position: absolute;
        top: -12px;
        left: -12px;
        background: rgba(0, 0, 0, 0.68);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(0, 255, 255, 0.25);
        border-radius: 6px;
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.2);
        transition: all 0.3s ease; /* smooth resize */
      }

      .overlay {
        position: relative;
        color: #0ff;
        text-shadow: 0 0 10px #0ff;
        font-size: 1.2rem;
        letter-spacing: 1px;
        line-height: 1.4;
        padding: 18px 18px 22px;
        pointer-events: auto;
        max-width: 340px;
      }
      .overlay a { color: #0ff; text-decoration: none; border-bottom: 1px dotted #0ff; }
      .overlay a:hover { opacity: 0.7; }
      .bio { font-size: 0.85em; opacity: 0.9; margin-top: 12px; line-height: 1.35; }

      @media (max-width: 640px) {
        .text-container { top: 15px; left: 15px; }
        .overlay { font-size: 1rem; padding: 16px; max-width: 290px; }
        .bio { font-size: 0.8em; }
      }
    </style>
  </head>
  <body>

    <div class="text-container">
      <div class="backdrop" id="backdrop"></div>
      <div class="overlay" id="overlay">
        tiagomoraismorgado<span style="opacity:0.5;">.github.io</span><br>
        <small>three.js • webgl • generative</small><br><br>
        
        <div class="bio">
          Composer, Coder & Conceptual Engineer<br>
          of Improvised Systems<br><br>
          Blending AI, Free Improvisation &<br>
          Experimental Audiovisual Languages<br><br>
          Developer of real-time visual &<br>
          granular synthesis systems using<br>
          SuperCollider & Processing<br><br>
          Exploring ChatGPT, LangChain &<br>
          decentralized platforms for<br>
          multimedia performance archiving<br><br>
          
          Open to collaborations in AI-driven<br>
          live coding & audiovisual improvisation<br><br>
        </div>
        
        <a href="https://github.com/tiagomoraismorgado" target="_blank">github</a> • 
        <a href="https://x.com/tiagomoraismorg" target="_blank">twitter/x</a>
      </div>
    </div>

    <!-- Three.js (unchanged) -->
    <script type="importmap">
      { "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/" } }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
      import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
      import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
      import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
      import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
      import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
      import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.z = 1000;

      const renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(1);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      composer.addPass(new AfterimagePass(0.95));
      const rgbShiftPass = new ShaderPass(RGBShiftShader);
      rgbShiftPass.uniforms.amount.value = 0.005;
      composer.addPass(rgbShiftPass);
      composer.addPass(new GlitchPass());
      composer.addPass(new FilmPass(0.35, 0.025, 648, false));

      const instancedMesh = new THREE.InstancedMesh(
        new THREE.SphereGeometry(2, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffffff }),
        2200
      );
      scene.add(instancedMesh);

      const atoms = [];
      const dummy = new THREE.Object3D();
      const gridSize = 60;
      const spacing = Math.min(window.innerWidth, window.innerHeight) / gridSize;
      let idx = 0;
      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          for (let z = 0; z < gridSize * 0.6; z++) {
            if (idx >= 2200) break;
            const baseX = x * spacing - (gridSize * spacing) / 2;
            const baseY = y * spacing - (gridSize * spacing) / 2;
            const baseZ = z * spacing * 0.8 - (gridSize * spacing * 0.3);
            atoms.push({ baseX, baseY, baseZ, phase: Math.random() * Math.PI * 2 });
            dummy.position.set(baseX, baseY, baseZ);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(idx++, dummy.matrix);
          }
        }
      }

      let t = 0;
      let glitch = 0;

      function animate() {
        requestAnimationFrame(animate);
        t += 0.02;
        glitch = Math.pow(Math.random(), 4);

        const pulse = Math.sin(t * 8) * 0.5 + 0.5;
        const explode = Math.random() > 0.7 ? Math.pow(Math.random(), 3) * 30 : 1;

        atoms.forEach((a, i) => {
          const nx = a.baseX + Math.sin(t * 2 + a.phase) * 80 * glitch * explode;
          const ny = a.baseY + Math.cos(t * 1.8 + a.phase) * 80 * glitch * explode;
          const nz = a.baseZ + Math.sin(t * 3 + a.phase * 1.3) * 60 * glitch;

          const screenX = nx + Math.sin(t + nz * 0.02) * 120 * pulse;
          const screenY = ny + Math.cos(t * 1.3 + nz * 0.015) * 120 * pulse;

          dummy.position.set(screenX, screenY, nz);
          const scale = THREE.MathUtils.mapLinear(Math.sin(t * 50 + a.phase * 10), -1, 1, 0.5, 3.5) * (1 + glitch * 10);
          dummy.scale.setScalar(scale);
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);
        });
        instancedMesh.instanceMatrix.needsUpdate = true;

        rgbShiftPass.uniforms.amount.value = 0.005 + glitch * 0.05;
        composer.passes[4].uniforms.intensity.value = 0.35 + glitch * 2;
        composer.passes[3].goWild = glitch > 0.5;
        composer.passes[1].uniforms.damp.value = 0.95 - glitch * 0.3;

        controls.update();
        composer.render();
      }
      animate();

      // === BACKDROP AUTO-RESIZE ===
      const backdrop = document.getElementById('backdrop');
      const overlay = document.getElementById('overlay');

      function resizeBackdrop() {
        const rect = overlay.getBoundingClientRect();
        backdrop.style.width = rect.width + 24 + 'px';   // +padding
        backdrop.style.height = rect.height + 24 + 'px';
      }

      // Run on load, resize, and after fonts load
      window.addEventListener('load', () => {
        setTimeout(resizeBackdrop, 100); // tiny delay for font rendering
      });
      window.addEventListener('resize', resizeBackdrop);
      // Also run immediately in case load already fired
      resizeBackdrop();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        resizeBackdrop();
      });
    </script>
  </body>
</html>
